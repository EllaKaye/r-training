{
  "hash": "d6979ab1038e30de690ac7bf358cf80c",
  "result": {
    "markdown": "---\ntitle: Programming in R\nsubtitle: R Foundations course\nauthor: Ella Kaye | Department of Statistics | University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2022-10-31\ndate-format: long\nformat: \n  revealjs:\n    theme: [default, ../../slides.scss]\n    slide-number: true\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n\n## Overview\n\n-   What we're covering\n\n## Intro\n\nUnderstanding the basics of R programming helps to improve\nanalysis/reporting scripts and extend what we can do with R.\n\nGood coding practice follows the DRY principle: **D**on't **R**epeat **Y**ourself. \nRather than modifying copy-pasted code chunks, we might\n\n- write a custom function\n- use loops or iteration functions to perform multiple similar tasks\n \nCustom functions can be used to provide convenient wrappers to complex \ncode chunks as well as implement novel functionality.\n\n\n# Section {background-color=\"#552D62\"}\n\n## Data Structures Revisited\n\nFor basic data analysis, our data is usually imported and we use \nhigh-level functions (e.g. from **dplyr**) to handle it.\n\nFor programming, we need to work with lower-level data structures and be\nable to\n\n- create basic objects\n- extract components\n- coerce one data type to another\n\nWorking with base R functions when programming also helps avoid dependencies, which is useful when writing packages.\n\n\n## Vectors\n\n`numeric()`, `character()` and `logical()` can be used to initialize \nvectors of the corresponding type for a given length\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- numeric(3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0\n```\n:::\n:::\n\n\nElements can be assigned by indexing the positions to be filled, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1] <- 4 # assign 4 to 1st element\nx[-c(2, 3)] <- 4 # assign 4 to everying *except* 2nd and 3rd element\n```\n:::\n\n\nThis is particularly useful when programming an iterative procedure.\n\n`as.logical()`, `as.numeric()` and `as.character()` coerce to the \ncorresponding type, producing `NA`s if coercion fails.\n\n## Logical Vectors\n\nLogical vectors are commonly used when indexing. The vector might be \nproduced by a logical operator:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 1, 2, 2, 2)\nx > 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nx[x > 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 2\n```\n:::\n:::\n\n`duplicated()` is also useful here:\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicated(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n!duplicated(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n## Numeric Vectors\n\nThe are several convenience function for creating\nnumeric vectors, notably `seq()` and `rep()`.\n\nAs they are so useful there are fast shortcuts for\nparticular cases\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_len(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"pear\", \"banana\")\nseq_along(fruits) # a sequence from 1 to the length of x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nrep.int(1:2, times = c(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 2 2 2\n```\n:::\n:::\n\n\n## Character Vectors\n\nCharacter vectors may be used for creating names\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3:5\nnames(x) <- paste0(LETTERS[1:3], 1229:1231)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A1229\" \"B1230\" \"C1231\"\n```\n:::\n:::\n\nNames can be used as an alternative to numeric or logical vectors when indexing\n\n::: {.cell}\n\n```{.r .cell-code}\nx[\"B1230\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nB1230 \n    4 \n```\n:::\n:::\n\n\n## Matrices\n\nA matrix is in fact also a vector, with an attribute giving the dimensions of the matrix\n\n::: {.panel-tabset}\n## default\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- matrix(1:6, 2, 3) # data, nrow, ncol\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nstr(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:2, 1:3] 1 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nattributes(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 2 3\n```\n:::\n:::\n\n\n## byrow\nThe `byrow` argument is also useful:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- matrix(1:6, 2, 3, byrow = TRUE) # data, nrow, ncol\nN\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n:::\n\n:::\n\n## Matrix functions \n\nUseful functions for matrices include `dim()`, `ncol()`, `nrow()`, \n`colnames()` and `rownames()`. `rbind()` and `cbind()` can be used to \nrow-bind or column-bind vectors.\n\nMatrices enable computation via matrix algebra as well as row/column-wise operations.\n\n## Lists\n\nLists collect together items which may be different types or lengths. Like a \nvector, elements may be named.\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- list(matrix = M, vector = x)\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$matrix\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n$vector\nA1229 B1230 C1231 \n    3     4     5 \n```\n:::\n:::\n\n\nLists are often used to return the results of a function. \n\n## Indexing lists\n\nElements can be indexed by `[` to return a list or `[[` to return a \nsingle element, either by index or name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults[\"vector\"] # returns a list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vector\nA1229 B1230 C1231 \n    3     4     5 \n```\n:::\n\n```{.r .cell-code}\nresults[[2]] # returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n:::\n:::\n\n\n\n`$` can be used to extract elements by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults$vector # equivalent to results[[\"vector\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n:::\n:::\n\n\n## Your turn!\n\nThe `lm` function calls the \"workhorse\" function `lm.fit` to actually \nfit the model. Unlike `lm`, which works from a formula, `lm.fit` works \nfrom the model matrix and the response vector.\n\n1. Define a response `y` containing 10 numeric values. Define an \nexplanatory variable `z` of the numbers 1 to 10.\n\n1. Use the function `cbind()` to create a matrix `x` with 1s in the first\ncolumn and `z` in the second column.\n\n1. Fit a model using `fit1 <- lm.fit(x, y)`. Use `str` to explore the structure of\nthe results. Use `$` to extract the coefficients.\n\n1. Create a second fit using `lm(y ~ z)`. Use `names` to compare the \nresults. Check the coefficients of the second fit are the same. \n\n## Your turn! (a solution)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A possible solution\n\nset.seed(1)\ny <- sample(10)\nz <- 1:10\n\nx <- cbind(1, z)\n\nfit1 <- lm.fit(x,y)\nstr(fit1)\nfit1$coefficients\n\nfit2 <- lm(y ~ z)\nnames(fit1)\nnames(fit2)\nfit2$coefficients\n```\n:::\n\n\n\n# End matter {background-color=\"#552D62\"}\n\n## Resources\n\nMaterial inspired by and remixed from:\n\n- \n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}